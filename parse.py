# Module for parsing and checking dependencies for vulnerabilities
# All other parsing modules are deprecated.

import logging
from requirements import parse as requirements_parse
import re
import sys
import requests
import json
import operator
from bs4 import BeautifulSoup
from enum import Enum
from typing import Iterator
from packaging.version import parse as packaging_parse_version, Version

# a mapping between comparative operators and their respective functions
OPERATORS = {
    '<': operator.lt,
    '<=': operator.le,
    '>': operator.gt,
    '>=': operator.ge,
    '==': operator.eq,
    '': operator.eq  # if the version number appears with no operator, it must be a specific version
}

# pre-compiling the following regexes to save time as they will be used a lot later
SPECIFIC_VERSION_PATTERN = re.compile(r"[0-9]+(\.[0-9]+)?(\.[0-9]+)?-?[a-zA-Z]*\.?[0-9]?")
VERSION_INTERVAL_PATTERN = re.compile(
    fr"(?P<opening_bracket>\[|\()\s*(?P<lower_version>{SPECIFIC_VERSION_PATTERN.pattern})?\s*,\s*(?P<higher_version>{SPECIFIC_VERSION_PATTERN.pattern})?\s*(?P<closing_bracket>\]|\))")
CVE_ID_PATTERN = re.compile(r"CVE-[0-9]{4}-[0-9]+")


def parse_version(version: str) -> Version:
    """A version might need cleaning to make it parsable. This functions handles the setup of the version's string
    and parses it using the `packaging` library"""

    version = ''.join([char for char in version if
                       char.isdigit() or char == '.'])  # remove ascii letters and other characters that aren't relevant for the version number to make it parsable
    return packaging_parse_version(version)


class ProjectType(Enum):
    PYTHON = 0
    NPM = 1


class VersionInterval:
    """Snyk alternates between using comparative operators (<,>,=) and intervals (e.g [0,1.13.1) )
    to represent the range of vulnerable versions. This class can handle version intervals and compare them."""

    @staticmethod
    def is_interval(interval: str) -> bool:
        """Checks whether a string has the structure of a version interval"""

        return re.fullmatch(VERSION_INTERVAL_PATTERN, interval) is not None

    def __init__(self, interval: str):
        if not self.is_interval(interval):
            raise ValueError(f"The given string: {interval!r} does not match the interval format")

        match = re.search(VERSION_INTERVAL_PATTERN, interval)
        self.opening_bracket = match.group("opening_bracket")
        self.lower_version = match.group("lower_version")
        self.higher_version = match.group("higher_version")
        self.closing_bracket = match.group("closing_bracket")

        self.lower_inclusive = self.opening_bracket == '['
        self.higher_inclusive = self.closing_bracket == ']'

        # Note that a lower/higher version bounds might be empty - in this case the version
        # is only bounded from one direction (i.e. has no upper/lower bound)
        # the intervals [,] and (,) correspond to any version

        if self.lower_version:
            self.lower_version = parse_version(self.lower_version)

        if self.higher_version:
            self.higher_version = parse_version(self.higher_version)


    def __contains__(self, item: Version):
        # One of the bounds might not exist

        # handle the lower version part
        if self.lower_version:
            op = OPERATORS['>=' if self.lower_inclusive else '>']
            if not op(item, self.lower_version):
                return False

        # handle the higher version part
        if self.higher_version:
            op = OPERATORS['<=' if self.higher_inclusive else '<']
            if not op(item, self.higher_version):
                return False

        return True



class PackageParser:

    # The parser uses Snyk to detect vulnerable versions of packages
    BASE_URL = "https://security.snyk.io"

    # Note on naming convention: a "base ... URL" is a complete url or the beginning of one, including the scheme
    # A url variable name without "base" means a partial url that should be appended to some base url
    PACKAGE_URL_PYTHON = "/package/pip"
    PACKAGE_URL_NPM = "/package/npm"

    # placeholder that is used when a vulnerability was not found
    TABLE_PLACEHOLDER = '-'


    def __init__(self, project_type: ProjectType):
        self.project_type = project_type

        if project_type == ProjectType.PYTHON:
            self.base_package_url = self.BASE_URL + self.PACKAGE_URL_PYTHON
            self.package_url = self.PACKAGE_URL_PYTHON
            self.parse_requirements_method = self.parse_requirements_file_python

        elif project_type == ProjectType.NPM:
            self.base_package_url = self.BASE_URL + self.PACKAGE_URL_NPM
            self.package_url = self.PACKAGE_URL_NPM
            self.parse_requirements_method = self.parse_requirements_file_npm

        else:
            raise NotImplementedError("The provided project type is not supported")


    @staticmethod
    def parse_requirements_file_python(requirements_path: str) -> dict:
        requirements = {}

        with open(requirements_path, 'r') as requirements_file:
            for requirement in requirements_parse(requirements_file.read()):
                name, specs = requirement.name, requirement.specs

                # specs should be of the format:
                # [("==", "version")]
                if not specs \
                    or (len(specs) != 1 and len(specs[0]) != 2) \
                    or specs[0][0] != "==" \
                    or not re.fullmatch(SPECIFIC_VERSION_PATTERN, specs[0][1]):
                        logging.warning(f"The requirement for '{name}' is not of the valid format (package-name==<version>). Skipping this requirement.")
                        continue

                version = specs[0][1]

                requirements[name] = version

        return requirements


    @staticmethod
    def parse_requirements_file_npm(requirements_path: str) -> dict:
        with open(requirements_path, 'r') as requirements_file:
            requirements_json = json.load(requirements_file)

            if 'dependencies' not in requirements_json:
                logging.error(f"The provided file ({requirements_path}) does not have dependencies.")
                sys.exit(1)

            dependencies = requirements_json['dependencies']

            dependencies_to_skip = []
            for name, version in dependencies.items():
                # verify that the version is a valid SPECIFIC version (i.e. no modifiers such as ^ and ~)
                if not re.fullmatch(SPECIFIC_VERSION_PATTERN, version):
                    logging.warning(
                        f"The requirement for '{name}' is not of the valid format (package-name: <version>). Skipping this requirement.")
                    dependencies_to_skip.append(name)

                # verify that the module is not a scoped npm module
                if name.startswith('@'):
                    logging.warning(f"Ignoring scoped module '{name}'")
                    dependencies_to_skip.append(name)

            for name in dependencies_to_skip:
                del dependencies[name]

            return dependencies


    def analyze_requirements(self, requirements: dict[str, str]) -> Iterator[tuple[str, str, str, str]]:
        """Analyze (check if vulnerable and if so find the CVE) the requirements.
        The requirements should be a dictionary of the form: {<package name>: <version>}

        The return value is a tuple of the form:
        (package name, version, CVE IDs list, Fixed Versions list)
        If the current library version is not vulnerable, a '-' will be used as a placeholder in the results table
        for the CVE and fixed version."""

        for name, version in requirements.items():
            vulnerability_links = self.verify_vulnerability(name, version)

            if vulnerability_links:
                cve_ids = []
                fixed_versions = []
                for link in vulnerability_links:
                    cve_id, fixed_version = self.get_cve_details(link)
                    cve_ids.append(cve_id)
                    fixed_versions.append(fixed_version)

            # the library with the current version is not vulnerable
            else:
                yield name, version, self.TABLE_PLACEHOLDER, self.TABLE_PLACEHOLDER
                continue

            yield name, version, '\n'.join(cve_ids), '\n'.join(fixed_versions)


    def verify_vulnerability(self, pkg_name: str, pkg_version: str) -> list[str]:
        """Check whether a certain version of a package is vulnerable.
        If it is, return a list of Snyk links to the vulnerabilities' pages.
        Otherwise, return None"""

        url = f"{self.base_package_url}/{pkg_name}/{pkg_version}"
        response = requests.get(url)

        # sometimes a version will be written in a shortened form such as 1.2 (instead of 1.2.0)
        # so if there isn't a page corresponding to the current version try to append a '.0' at the end
        if response.status_code == 404:
            response = requests.get(f"{url}.0")

        if not response.ok:
            logging.error(f"Failed look up the package {pkg_name!r}, received status code {response.status_code}")
            return ["Unresolved"]

        pkg_version = parse_version(pkg_version)
        vuln_links = []

        if "No direct vulnerabilities have been found for this package" in response.text:
            return vuln_links

        soup = BeautifulSoup(response.text, 'html.parser')

        for vulnerable_versions_div in soup.find_all('div', attrs={'class': 'vulnerable-versions'}):

            done = False
            vuln_link = None

            for vulnerable_version_restrictions_span in vulnerable_versions_div.findChildren('span'):
                version_restrictions_list = vulnerable_version_restrictions_span.text.strip().split(' ')

                matching_conditions_count = 0

                for version_restriction in version_restrictions_list:
                    # handle an asterisk as a wildcard to match anything according
                    # to Snyk's convention
                    if version_restriction == '*':
                        done = True
                        break

                    elif VersionInterval.is_interval(version_restriction):
                        version_restriction_interval = VersionInterval(version_restriction)
                        if pkg_version in version_restriction_interval:
                            done = True
                            break

                    else:
                        op, required_version = re.search(r"([=><]{1,2})([0-9\.]+)", version_restriction).groups()
                        operation = OPERATORS[op]
                        required_version = parse_version(required_version)

                        if operation(pkg_version, required_version):
                            # if the requirement for the version is to equal some version,
                            # no further checking is needed (this is checked to mitigate the problem of two checks of '==' for different versions)
                            if operation == operator.eq:
                                done = True  # once the vulnerability is verified there's no need to keep going through the conditions
                                break

                            matching_conditions_count += 1

                if matching_conditions_count == len(version_restrictions_list) or done:
                    pkg_name_without_punctuation = ''.join([char for char in pkg_name if char.isalnum()])
                    vuln_link_tag = vulnerable_versions_div.find_previous('a', attrs={'href': re.compile(fr"vuln/SNYK-.*({pkg_name}|{pkg_name_without_punctuation}).*", re.IGNORECASE)})

                    if vuln_link_tag:
                        vuln_link = vuln_link_tag['href']
                        vuln_links.append(vuln_link)
                        break

        return vuln_links


    def get_cve_details(self, vuln_link: str) -> tuple[str, str]:
        """Use the link to the vulnerability page to find the relevant CVE ID and the closest fixed version"""

        cve_id = "Unavailable"
        fixed_version = "Unavailable"

        if vuln_link == "Unresolved":
            return cve_id, fixed_version

        response = requests.get(f"{self.BASE_URL}/{vuln_link}")
        soup = BeautifulSoup(response.text, 'html.parser')

        if "CVE NOT AVAILABLE" not in response.text:
            cve_id = soup.find('a', attrs={'id': CVE_ID_PATTERN})['id']

        version_upgrade_pattern = re.compile(fr"Upgrade .+ to version (?P<fixed_version>{SPECIFIC_VERSION_PATTERN.pattern}).* or higher\.")
        for p_tag in soup.find_all('p'):
            if re.fullmatch(version_upgrade_pattern, p_tag.text):
                fixed_version = re.search(version_upgrade_pattern, p_tag.text).group("fixed_version")

        return cve_id, fixed_version


    def scan(self, requirements_path: str) -> Iterator[tuple[str, str, str, str]]:
        """A convenience function to both parse the requirements/dependencies file and scan it for vulnerabilities.
        The return value is a tuple of the form:
        (package name, version, CVE ID, Fixed Version)"""

        requirements = self.parse_requirements_method(requirements_path)
        return self.analyze_requirements(requirements)

